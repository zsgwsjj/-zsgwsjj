---
title: 网络相关
date: 2019-10-25 17:13:40
type: "网络相关"
---

### 消息队列
* 优点
    * 解耦
    * 异步
    * 削峰
* 缺点
    * 系统可用性降低
    * 系统复杂度提高
    * 一致性问题
    
|特性|ActiveMQ|RabbitMQ|RocketMQ|Kafka|
|:---|:---|:----|----|----|
|单机吞吐量	|万级，比 RocketMQ、Kafka 低一个数量级	|同 ActiveMQ	|10 万级，支撑高吞吐	|10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景
|
|topic 数量对吞吐量的影响	|||topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic	|topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源
|
|时效性	|ms 级	|微秒级，这是 RabbitMQ 的一大特点，延迟最低	|ms 级	|ms 级	|
|可用性	|高，基于主从架构实现高可用	|同 ActiveMQ	|非常高，分布式架构	|非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用
|
|消息可靠性		|有较低的概率丢失数据	|基本不丢	|经过参数优化配置，可以做到 0 丢失	|同 RocketMQ
|
|功能支持		|MQ 领域的功能极其完备	|基于 erlang 开发，并发能力很强，性能极好，延时很低	|MQ 功能较为完善，还是分布式的，扩展性好	|功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用
|


#### Rabbit MQ的高可用性
`基于主从`
* 单机模式
* 普通集群模式
    * 每个queue配置信息同步
    * 数据只存在于其中一个queue
    * 随机连接到其中一个queue之后根据配置信息从存放数据的queue中拉取数据
    * 不是高可用，提高了吞吐性能
* 镜像集群模式
    * 高可用模式
    * 所有节点配置信息以及数据完全一样
    * 每次写消息会自动吧消息同步到所有/多个queue上
    * 该模式没有扩展性，无法线性扩展queue的性能

#### Kafka的高可用性
##### 架构组成
* 多个broker组成，每个broker是一个节点
* 一个topic划分为多个partition,每个partition存在不同的broker上面
* 每个partition存放一部分数据

##### 高可用分析
* 天然的分布式消息队列
* 一个topic的数据分散在多个机器上，每个机器存放一部分数据
* replica副本机制
    * 每个partition都会同步到其他机器上，形成自己的副本
    * 所有的replica会选举出一个leader，其余的是follower
    * 读写都发生在leader上


### 保证消费的幂等性

### 避免消息的丢失
#### Rabbit
##### 生产者丢失数据
`采用rabbitMQ的事务`
* 发送数据之前开启RabbitMQ的事务`channel.txSelect`
* 如果没Rabbit没接受到数据，会报错。
* 使用`channel.txRollback`回滚，使用`channel.txCommit`提交事务
* 事务太消耗性能，影响吞吐量

`采用Rabbit MQ的 confirm机制`
* 生产者设置开启
* 每条消息会分配一个唯一的id
* 写入成功则ack，失败则nack，可以再内存维护id的状态，长时间没收到返回也认为失败

###### 两者的不同
* 事务机制是同步的，会阻塞后续的请求
* confirm是一步的，都是采用该模式

##### RabbitMQ弄丢了数据
